<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Call Debugger</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background-color: #0056b3;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #545b62;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c82333;
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .status {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.connecting {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .log-container {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 20px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        .log-entry {
            margin-bottom: 8px;
            padding: 4px 0;
        }
        .log-entry.info {
            color: #0066cc;
        }
        .log-entry.success {
            color: #28a745;
        }
        .log-entry.error {
            color: #dc3545;
        }
        .log-entry.warning {
            color: #ffc107;
        }
        .log-entry.debug {
            color: #6c757d;
        }
        .audio-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .audio-card {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
        }
        .audio-card h3 {
            margin-top: 0;
            color: #333;
        }
        .volume-meter {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        .volume-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #ffc107, #dc3545);
            transition: width 0.1s ease;
        }
        .clear-btn {
            background-color: #6c757d;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .clear-btn:hover {
            background-color: #545b62;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Voice Call Debugger</h1>
            <p>Test WebSocket audio streaming with microphone input</p>
        </div>

        <div id="status" class="status disconnected">
            Status: Disconnected
        </div>

        <div class="controls">
            <button id="startBtn" class="btn btn-primary">Start Call</button>
            <button id="stopBtn" class="btn btn-danger" disabled>Stop Call</button>
            <button id="clearLogBtn" class="btn btn-secondary">Clear Log</button>
        </div>

        <!-- Audio visuals removed as requested -->

        <div>
            <h3>Event Log</h3>
            <div id="logContainer" class="log-container"></div>
        </div>
    </div>

    <script>
        class VoiceCallDebugger {
            constructor() {
                this.websocket = null;
                this.mediaStream = null;
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.audioDestination = null;
                this.audioBufferFloats = [];
                this.nextPlaybackTime = 0;
                this.isConnected = false;
                this.isRecording = false;
                
                this.initializeElements();
                this.bindEvents();
            }

            initializeElements() {
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.clearLogBtn = document.getElementById('clearLogBtn');
                this.statusDiv = document.getElementById('status');
                this.logContainer = document.getElementById('logContainer');
                
                // Audio visuals removed
            }

            bindEvents() {
                this.startBtn.addEventListener('click', () => this.startCall());
                this.stopBtn.addEventListener('click', () => this.stopCall());
                this.clearLogBtn.addEventListener('click', () => this.clearLog());
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;
                this.logContainer.appendChild(logEntry);
                this.logContainer.scrollTop = this.logContainer.scrollHeight;
            }

            clearLog() {
                this.logContainer.innerHTML = '';
                this.log('Log cleared', 'info');
            }

            updateStatus(status, className) {
                this.statusDiv.textContent = `Status: ${status}`;
                this.statusDiv.className = `status ${className}`;
            }

            async startCall() {
                try {
                    this.log('Starting voice call...', 'info');
                    this.updateStatus('Connecting...', 'connecting');
                    
                    // Request microphone permissions
                    this.log('Requesting microphone permissions...', 'info');
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            channelCount: { ideal: 1 },
                            sampleRate: { ideal: 24000 },
                            sampleSize: 16
                        } 
                    });
                    
                    this.log('Microphone access granted', 'success');
                    // visuals removed
                    
                    // Initialize WebSocket connection
                    await this.connectWebSocket();
                    
                    // Initialize audio context and streaming
                    await this.initializeAudio();
                    
                    this.isConnected = true;
                    this.startBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    this.updateStatus('Connected', 'connected');
                    this.log('Voice call started successfully', 'success');
                    
                } catch (error) {
                    this.log(`Error starting call: ${error.message}`, 'error');
                    this.updateStatus('Connection Failed', 'disconnected');
                }
            }

            async connectWebSocket() {
                return new Promise((resolve, reject) => {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws`;
                    
                    this.log(`Connecting to WebSocket: ${wsUrl}`, 'info');
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        this.log('WebSocket connected', 'success');
                        resolve();
                    };
                    
                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketMessage(data);
                        } catch (error) {
                            this.log(`Error parsing WebSocket message: ${error.message}`, 'error');
                        }
                    };
                    
                    this.websocket.onerror = (error) => {
                        this.log(`WebSocket error: ${error}`, 'error');
                        reject(error);
                    };
                    
                    this.websocket.onclose = (event) => {
                        this.log(`WebSocket closed: ${event.code} - ${event.reason}`, 'warning');
                        this.handleDisconnection();
                    };
                });
            }

            async initializeAudio() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 24000,
                    latencyHint: 'interactive'
                });
                
                // Create microphone source
                this.microphone = this.audioContext.createMediaStreamSource(this.mediaStream);
                
                // Create analyser for volume monitoring
                // analyser visuals removed
                
                // Create audio destination for playback
                this.audioDestination = this.audioContext.createMediaStreamDestination();
                
                // visuals removed
                
                // Start audio streaming
                this.startAudioStreaming();
                
                this.log('Audio context initialized', 'success');
            }

            // visuals removed

            startAudioStreaming() {
                if (!this.isRecording) {
                    this.isRecording = true;
                    this.log('Starting audio streaming to WebSocket', 'info');
                    
                    // Use a smaller buffer size for lower latency
                    const bufferSize = 1024; // smaller buffer for lower latency
                    const processor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);
                    this.microphone.connect(processor);
                    // Prevent any local playback/feedback; route through a muted gain
                    const muteGain = this.audioContext.createGain();
                    muteGain.gain.value = 0;
                    processor.connect(muteGain);
                    muteGain.connect(this.audioContext.destination);
                    
                    processor.onaudioprocess = (event) => {
                        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                            const inputData = event.inputBuffer.getChannelData(0);
                            // Ensure we send PCM16 to server (model expects PCM16 per logs)
                            const audioData = this.convertFloat32ToPCM16(inputData);
                            const base64Data = btoa(String.fromCharCode(...new Uint8Array(audioData.buffer)));
                            
                            const message = {
                                kind: "AudioData",
                                audioData: {
                                    data: base64Data
                                }
                            };
                            
                            this.websocket.send(JSON.stringify(message));
                            
                            // Optional: uncomment to debug outbound samples
                            // if (Math.random() < 0.01) {
                            //     this.log(`Sending audio: ${inputData.length} samples -> ${audioData.length} bytes (16-bit PCM)`, 'debug');
                            // }
                        }
                    };
                }
            }

            convertFloat32ToPCM16(float32Array) {
                // Convert Float32 to 16-bit PCM (little-endian)
                const pcm16Array = new Int16Array(float32Array.length);
                for (let i = 0; i < float32Array.length; i++) {
                    const sample = Math.max(-1, Math.min(1, float32Array[i]));
                    pcm16Array[i] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                }
                return new Uint8Array(pcm16Array.buffer);
            }

            handleWebSocketMessage(data) {
                this.log(`Received message: ${JSON.stringify(data)}`, 'debug');
                
                if (data.kind === "AudioData") {
                    this.playAudioData(data.audioData.data);
                }
            }

            playAudioData(base64Data) {
                try {
                    const binaryString = atob(base64Data);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }

                    // Expected model output: PCM16 (int16) little-endian at 24kHz mono
                    const SAMPLE_RATE = 24000;
                    const format = 'pcm16';
                    const bytesPerSample = 2;
                    const numSamples = Math.floor(bytes.length / bytesPerSample);

                    // Initialize audio buffer if not exists
                    if (!this.audioBuffer) {
                        this.audioBuffer = [];
                        this.audioBufferFloats = [];
                        this.lastPlayTime = 0;
                        this.nextPlaybackTime = 0;
                    }

                    // Convert to Float32 depending on detected format
                    if (format === 'pcm16') {
                        for (let i = 0; i < numSamples; i++) {
                            const byteOffset = i * bytesPerSample;
                            const lo = bytes[byteOffset];
                            const hi = bytes[byteOffset + 1];
                            const sampleInt16 = (hi << 8) | lo;
                            const signed = sampleInt16 & 0x8000 ? sampleInt16 - 0x10000 : sampleInt16;
                            this.audioBufferFloats.push(signed / 32768);
                        }
                    }
                    
                    // Play audio in small, scheduled chunks to avoid jumbled playback
                    const chunkSamples = Math.floor(SAMPLE_RATE * 0.02); // ~20 ms per chunk
                    while (this.audioBufferFloats.length >= chunkSamples) {
                        const slice = this.audioBufferFloats.splice(0, chunkSamples);
                        const audioBuffer = this.audioContext.createBuffer(1, slice.length, SAMPLE_RATE);
                        audioBuffer.copyToChannel(new Float32Array(slice), 0, 0);

                        const source = this.audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(this.audioContext.destination);

                        const currentTime = this.audioContext.currentTime;
                        if (this.nextPlaybackTime < currentTime) {
                            this.nextPlaybackTime = currentTime + 0.01; // small lead-in
                        }
                        source.start(this.nextPlaybackTime);
                        this.nextPlaybackTime += audioBuffer.duration;
                    }

                    // visuals removed
                    
                } catch (error) {
                    this.log(`Error playing audio: ${error.message}`, 'error');
                    this.log(`Audio data length: ${base64Data.length} base64 chars`, 'debug');
                }
            }

            stopCall() {
                this.log('Stopping voice call...', 'info');
                
                if (this.websocket) {
                    this.websocket.close();
                    this.websocket = null;
                }
                
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                // Clear audio buffer
                this.audioBuffer = null;
                this.audioBufferFloats = [];
                this.lastPlayTime = 0;
                this.nextPlaybackTime = 0;
                
                this.isRecording = false;
                this.isConnected = false;
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                
                // visuals removed
                
                this.updateStatus('Disconnected', 'disconnected');
                this.log('Voice call stopped', 'info');
            }

            handleDisconnection() {
                if (this.isConnected) {
                    this.stopCall();
                }
            }
        }

        // Initialize the debugger when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new VoiceCallDebugger();
        });
    </script>
</body>
</html>
